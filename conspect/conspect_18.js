'use strict';

// * Модульная структура
console.log('Модульная структура');


// 1) Start Code
console.log(`____________________________________________________________________________________

`);

// * 1) Метод Инкапсуляции
// Это сложение данных и функций в один компонент, например функция, класс, объект и т.д. Допустим в каждом отдельном файле создаётся фунеция отвечающая за что-то одно.
console.log('1) Метод Инкапсуляции');

// * 1-1) Пример без Инкапсуляции
// При подключении нескольких файлов переменная slider может быть и в них, что приведёт к ошибке
console.log('\n \n 1-1) Пример без Инкапсуляции');

const slider = '\n \n 1-1) Slider - Пример без Инкапсуляции';
console.log(slider);


// * 1-2) Инкапсуляции - Пример с использованием функции и её области видимости
// Создаём переменную внутри которой создаём удобные название переменных и используем область видимости фунеции, далее её вызываем
// - что название самой функии тоже может повторяться в других подключенных файлах вроде сторонних библиотек, что тоже приведёт к ошибке
console.log('\n \n 1-2) Инкапсуляции - Пример с использованием функции и её области видимости');

// * Обычная анонимная функция внутри переменной
const sliderFunction_1 = () => {
    const slider = '\n \n 1-2) Slider - Обычная анонимная функция внутри переменной';
    console.log(slider);
};

sliderFunction_1();

// * 1-3) Анонимная самовызывающиеся функция - Пример Инкапсуляции
// Это функция, которая вызвается в момент её написания
// Для того, чтобы из обычной функции сделать анонимную самовызывающиеся функцию, мы должны обычную функции взять в круглые скобки () и далее добавить её же вызов через ()
console.log('\n \n 1-3) Анонимная самовызывающиеся функция');

(function () {
    const slider = '1-3-1) Slider - Анонимная самовызывающиеся функция';
    console.log(slider);
})();

// * Такую функцию можно написать в виде =>
// (() => {
//    тело фукции
// })
(() => {
    const slider = '1-3-2) Slider - Анонимная самовызывающиеся стрелочкая функция =>';
    console.log(slider);
})();




// * 2) Модуль - Модульный подход
// Модуль это законченный и абсолютно независимый функциональный блок
console.log('\n \n 2) Модуль - Модульный подход');

// Инкапсуляция кода
const sliderModule = () => {
    const slider = 'Slider';

    console.log(slider);
};

// * 2-1) module.exports команда
// Таким образом мы экспортируем данную функцию sliderModule из файла, где находится эта функция
// module.exports = sliderModule; // ПРИМЕР
console.log(' 2-1) module.exports команда');


// * 2-2) require() - Создаём переменные, в которые поместим функции
// Внутри require() в виде строки '' передаём путь к нашему модулю. Расширение формата .js писать необязательно.
// const slider = require('./modules/slider');  // ПРИМЕР
console.log(' 2-2) require() - Создаём переменные, в которые поместим функции');


// * 2-3) Browserify - Один из инструментов сборки проекта. Но по факту используют webpack
// https://browserify.org/
// npm install -g browserify
// Флажочек -g означает, что данная библиотека установится на ПК глобально

// browserify main.js -o bundle.js
// Где main.js это название файла точки входа, унас это src/index.js
// Где bundle.js это название файла, который создаст инструмент browserify, у нас это будет dist/bundle.js

// browserify src/index.js -o dist/bundle.js     // Так выглядит финальная запись
// Далее в index.html мы должны подключить итоговый файл dist/bundle.js
console.log(' 2-3) Browserify - Один из инструментов сборки проекта. Но по факту используют webpack');




// * 3) Webpack - инструмент сборки проекта
// https://webpack.js.org/
console.log('\n \n 3) Webpack - инструмент сборки проекта');





// * 3-1) Webpack - Установка
console.log('3-1) Webpack - Установка');
// mkdir webpack-demo — Создаёт папку
// cd webpack-demo — Переходит в папку

// * 3-2) npm init и Настройка              // -y не указываем
console.log('3-2) npm init и Настройка');
// Инициализирует наш проект, то-есть определяет его. Если бы мы указали флажочек -y, то мы согласились бы на все настройки по умолчанию.

// * Настройки - все настройки можем заполнить уже после инициализации
// package name — Название проекта
// version — Версия
// description — Описание проекта, которое мы можем добавить
// entry point — Точка входа, обычно это index.js
// test command — Пока пропускаем
// git perository — Пока пропускаем
// keyword — Ключевые слова нашего проекта, пока пропускаем
// author — Автор
// lisense — Лицензия по умолчанию стоит откртыая лицензия ISC


// * 3-3) package.json - после команды npm init и заполнения настроек получаем файл со всеми настройками
// Сам файл package.json это основной файл описания нашего проекта. В нём будут указаны все библиотеки, которые мы будем использовать в будущем, в том числе и библиотека Webpack
console.log('3-3) package.json - после команды npm init и заполнения настроек получаем файл со всеми настройками');


// * 3-4) npm install webpack webpack-cli --save-dev
// Устанавливает локально в наш проект две библиотеки webpack и webpack-cli в файл package.json. Не глобально на ПК, а локально для работы с конкретным проектом
// Создаёт папку node_modules
// Создаёт файл package-lock.json
console.log('3-4) npm install webpack webpack-cli --save-dev');


// * 3-5) npm i - установка зависимостей и пытаемся разобраться, что происходит
// Файл package-lock.json и папка node_modules создаются одной командой на основании нашего package.json, то-есть хранить их где-то в облаке (например на GitHub) не нужно.
// Чтобы вновь создать эти файлы и папки из записей файла package.json используем команду npm i
// package-lock.json отвечает за связь разных библиотек. Библиотеки могут состоять других библиотек и они зависят друг друга. Когда мы устанавливаем одну библиотку, то в папку node_modules попадают и другие зависимые библиотеки
console.log('3-5) npm i - установка зависимостей');


// * 3-6) .gitignore
// На одном уровне с index.html, то-есть в корне проекта создаётся файл .gitignore
// Внутри этого файла необходимо указать папку /node_modules и файл package-lock.json. Эти файлы не будут попадут в отслеживание гитом
// package-lock.json всегда зависит от ПК на котором разворачивается проект
console.log('3-6) .gitignore');


// * 3-7) npx webpack - Собираем проект с Webpack
console.log('3-7) npx webpack - Собираем проект с Webpack');
// Появляется папка dist, а внутри появляется файл main.js в котором миницифированы наши модули JS



// * 3-8) npm run build - Запускаем Webpack с помощь npm run build
//В package.json меняем команду test на build, а содержимое меняем на webpack. Теперь мы можем собирать нашку сборку командой npm run build
// "build": "webpack"
console.log('3-8) Запускаем Webpack с помощь npm run build');


// * 3-9) npm run watch - Настройка watch для отслеживания
// В package.json добавляем настройку в scripts "watch": "webpack --watch"
// Запускаем Live Server и npm run watch
console.log('3-9) Настройка watch для отслеживания');


// * 3-10) Импорт и Экспорт стандарта ES6
// Вместо module.exports = sliderModule; указываем exports default
console.log('3-10) Импорт и Экспорт стандарта ES6');

// * export default и import
// Меняем строчку
// module.exports = sliderModule;
// на
// * export default sliderModule;

// Но в консоли будет ошибка. Если мы экспортируем по дефолту, то и импортировать должны по дефолту

// Нужно перейти в index.js, найти наш модуль (sliderModule) и заменить строчку
// const slider = require('./modules/slider');
// на
// * import sliderOne from './modules/slider';



// * 3-11) Webpack dev server
// webpack.config.js создаём в корневой папке на уровне index.html и .gitignore
// Все настройки будут хранится в объекте и мы должны как модуль его экспортировать

// Далее указываем две основные настройки:
//    * entry - путь к нашей точке входа    //   entry: './src/index.js'
//    * output - путь к нашей точке выхода
//      ouptu это объект, в который мы должны передать имя(filename: 'main.js') исходящего файла и путь(path) в который он удет помещаться.
// * С path есть нюанс, что мы должны указать абсолютный путь, потому что если мы укажем путь вроде './src/dist' и попробуем собрать наш проект, то получим ошибку. Для решения мы обратимся к дополнительной библиотеке path, которая уже находится в нашей среде разработк node.js, дополнительно устанавливать её не нужно, это базовый инструментарий node.js
// const path = require('path');

// * Метод resolve объединяет несколько путей
// * __dirname являвется нашим корневым каталогом (вся папка разработки)
// * 'dist' папка в которую мы делаем сборку и куда будет помещаться наш 'main.js'
//  path: path.resolve(__dirname, 'dist')

// Будет WARNING и нас попросят добавить mode
// "build": "webpack --mode=production",
// "watch": "webpack --watch --mode=development"

// * Далее мы будем достаточно часто указывать папку src и можем занести её в некий context
// context: path.resolve(__dirname, 'src')

// * npm i webpack-dev-server --D
// Заменяем Live Server внутренним инструментарием webpack
// --D устанавливаем зависимость только в devDependencies
// Создаём объект devServer, который отвечает за настройку
// hot: true следит за изменениями, чтобы страница перезагружалась
// В  static:  указываем за какой directory следить и watch: true, чтобы следить
// В package.json создаём ещё один script
// "start": "webpack serve --mode=development --open"

console.log('3-11) ');



// 1) End Code
console.log(`____________________________________________________________________________________

`);