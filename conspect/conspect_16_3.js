'use strict';

// * Особенности современного стандарта ES6 - ECMAScript 6
// На самом деле комитет выпускает стандарт каждый год, но ES6 привнёс в язык наибольшее количество глобальных нововведений, о самых важных мы поговорим и рассмотрим
console.log('Особенности современного стандарта ES6 - ECMAScript 6');


// 1) Start Code
console.log(`____________________________________________________________________________________

`);


// * 3) Деструктуризация
// Данный инструмент позволит сократить код, сделать более читабельным и не создавать лишних переменных.
console.log('3) Деструктуризация');

const user = {
    name: 'Ser',
    age: 31,
    isAuth: false,
    projects: {
        firstProject: 'First text.',
        secondProject: 'Second text.'
    }
};

// Ранее для работы со значениями свойств объектов нам приходилось (1-ый случай)либо складировать значение свойства в какую-то переменную, (2-ой случай)либо обращаться к самомуо объекту доставать это значение через него.
// 1-ый случай - Создаём лишнюю переменную и выводим её в консоль
const name_1 = user.name;
console.log(name_1);

// 2-ой случай - Пишем чуть больше когда, когда обращаемся к свойству объекта и выводим в консоль
console.log(user.name);

// * 3-1) 3-ий случай - Деструктуризация объекта/object
// Давайте каждое свойство получим через отдельную переменную и посмотрим насколько мы сократим код благодаря Деструктуризации
console.log(`\n \n 3-1) 3-ий случай - Деструктуризация объекта/object`);

// const name = user.name;
// const age = user.age;
// const isAuth = user.isAuth;
// * Выполним тот же функционал, но только через Деструктуризацию
// Название переменной после Деструктуризации наследуется от названия свойства объекта, но это можно изменить если мы добавим : и название переменной, пример nameUser
const { name: nameUser, age, isAuth, projects, projects: { firstProject, secondProject } } = user;


console.log(nameUser);
console.log(age);
console.log(isAuth);

// Но что если в нашем объекте user присутствует вложенный объект?
console.log(projects);

// Что если, нам нужны вложенные свойства внутри вложенного объекта?
console.log(firstProject);
console.log(secondProject);




// * 3-2) Деструктуризация массива/array
console.log(`\n \n 3-2) Деструктуризация массива/array`);

// Ранее, чтобы получить доступ к каждому из элементов, мы должны были обратиться к нему по индексу
const names = ['Ser', 'Polly', ['Alex', 'Amily'], ['Adriya', 'Argula']];

// const ser = names[0];
// const polly = names[1];
// * Но обращаться по индексу не очень удобно, можем Деструктуризировать
const [ser, polly, other, [adriya, argula]] = names;

//Но что, если нам нужно получать не вложенный массив целиком, а нужно добраться до самих значений

console.log(ser);
console.log(polly);

// Мы так же можем делать вложенные массивы вроде other
console.log(other);

// Мы так же можем добраться до вложенныз значений, предварительно обернув их в []
console.log(adriya);
console.log(argula);




// * 3-3) Применение Деструктуризации в жизни
console.log(`\n \n 3-3) Применение Деструктуризации в жизни`);

// Функция выводит в консоль введённые даные
const logger_1 = (log) => {
    console.log(log);
};

logger_1('test');

// Но что если параметров несколько?
const logger_2 = (first, second, third) => {
    console.log(`${first} ${second} ${third}.`);
};

logger_2('I', 'love', 'JavaScript');

// Но что если аргументы поменяются местами, как это часто бывает в JS? Наша строка ломается =(
logger_2('I', 'JavaScript', 'love');

// * Что делать в данном случае?
// По факту мы передаём три аргумента и принимает три параметра самой функции. А что если мы передадим не три аргумента, а объект со свойстами?
const logger_3 = (obj) => {
    // Мы получаем объект состоящий из трёх свойств и по идее можно каждое свойство класть в отдельную переменную и выводить в нужной нам последовательности, но это не очень удобно. Мы можем сделать это проще. Сейчас мы получаем параметром некий obj, Деструктурируем его и выводим в консоль необходимые свойства в нужном нам порядке
    const { first, second, third } = obj;
    console.log(obj);
    console.log(first, third, second);

    // * Давайте попробуе ЕЩЁ упрастить данную запись
};

// Мы можем сделать это гораздо проще.
logger_3({ first: 'I', second: 'Javascript', third: 'love' });




// * Давайте попробуе ЕЩЁ упрастить данную запись
// * ДАННЫЙ способ передачи объекта очень распространён во всех фреймворках JS и его лучше запомнить
// Мы можем избавиться от отдельной переменной obj сразу Деструктурирова наш объект
// В данном случае, мы получаем несколько преимуществ - пишем меньше когда, мы понимаешь, что внутри () получаем параметр объект и обращаемся к каждому свойству этого объекта и ещё огромным преимущество является, что нам нет смысла передавать в праивльно последовательности наши аргументы.
const logger_4 = ({ first, second, third }) => {
    console.log(`${first} ${second} ${third}.`);
};

// Создание тестого объекта для практики
const loggerObjTest = {
    first: 'I',
    second: 'Javascript',
    third: 'love'
};

logger_4({ first: 'I', second: 'Javascript', third: 'love' });
logger_4(loggerObjTest);